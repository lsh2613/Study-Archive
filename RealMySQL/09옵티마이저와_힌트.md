# 09 옵티마이저와 힌트

# 9.1 개요
- MySQL 서버로 요청된 쿼리의 결과는 동일하지만 내부적으로 결과를 만들어내는 방법은 다양하다
- 최적의 방법, 최소의 비용을 통해 최적의 실행계획을 만들어내는 작업을 `옵타마이저`가 담당한다
- `EXPLAIN` 명령어를 통해 쿼리의 실행계획을 확인할 수 있다

## 9.1.1 쿼리 실행 절차
1. SQL 파서 - SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리하여 SQL 파스 트리를 생성
2. 옵티마이저 - SQL 파스 트리를 확인하며 실행 계획 수립
    - 불필요 조건 제거
    - 복잡한 연산 단순화
    - 여러 조인 -> 어떤 순서로 테이블 읽을지
    - 어떤 인덱스 사용할지
    - 등등
3. MySQL 엔진과 스토리지 엔진 - 실행계획에 따라 스토리지 엔진에서 데이터 조회


## 9.1.2 옵티마이저의 종류
### 비용 기반 옵티마이저 (Cost Based Optimizer, CBO)
- 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만듦
- 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 통해 실행 계획별 비용 산출
- 최소 비용의 실행 계획을 통해 쿼리 처리
- 대부분의 DBMS가 선택

### 규칙 기반 옵티마이저 (Rule Based Optimizer, RBO)
- 테이블의 레코드 건수, 선택도 등을 고려하지 않고 옵티마이저에 내장된 우신선위에 따라 실행계획을 수립
- 따라서 같은 쿼리에 대해 거의 항상 같은 실행 방법을 만들어낸다
- 데이터 분포가 매우 다양하기 때문에 거의 사용되지 않는다

# 9.2 기본 데이터 처리
## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
### 옵티마이저의풀 테이블 스캔 선택 조건
  - 레코드 건수가 너무 작아 인덱스 보다 풀 테이블 스캔이 빠른 경우
  - `WHERE` 절이나 `ON` 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔이 가능하더라도 옵티파이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
### InnoDB의 풀 테이블 스캔
- 특정 테이블의 연속된 데이터 페이지가 읽히면 `백그라운드 스레드`에 의해 `리드 어헤드(Read ahead)` 작업이 자동으로 시작된다
- 반면 `MyISAM`은 풀 테이블 스캔 시 디스크로부터 페이지를 하나씩 읽어온다
> Read ahead란?<br>
> 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 `예측`해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것 <br>
> 즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 읽지만, 특정 시점부터 백그라운드 스레드가 넘겨받아 페이지 읽기를 실행한다 <br>
> Read ahead는 `풀 테이블 스캔` 뿐만 아니라 `풀 인덱스 스캔`에서도 동일하게 사용된다

- count()같이 단순 건수 조회는 풀 테이블 스캔 보다는 용량이 작고 빠른 풀 인덱스 스캔이 선택될 확률이 높다

``` sql
# 풀 인덱스 스캔
select count(*) from employees;

# 풀 테이블 스캔
select * from employees;
```
> 세컨더리 인덱스는 value로 pk를 가지고 있어 레코드를 조회하기 위해 다시 pk에 대응되는 레코드를 읽어야 해서 느리다. 하지만 단순 건수만 조회하는 것은 pk를 조회하지 않아도 되기 때문에 어찌보면 당연한 말인 것 같다

## 9.2.2 병렬 처리
- MySQL 8.0 이후부터 하나의 쿼리에 대해 여러 스레드가 병렬 처리를 할 수 있게 되었다.
- `innodb_parallel_read_threads` 라는 변수로 하나의 쿼리를 최대 몇개의 스레드가 처리할지 설정할 수 있다.
- 단, 아무런 `WHERE 조건 없이` 테이블의 `전체 건수`를 가져오는 쿼리만 병렬로 처리할 수 있다

## 9.2.3 ORDER BY 쿼리 (Using filesort)
### 정렬 처리 방법
| 방법         | 장점                                                                                          | 단점                                                                                           |
|--------------|-----------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
| 인덱스 이용  | 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.                        | 쓰기 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 디스크 공간이 더 많이 필요하다. 인덱스의 개수가 늘어날수록 버퍼 풀을 위한 메모리가 많이 필요하다. |
| Filesort 이용 | 인덱스를 이용할 때의 단점이 없어진다. 정렬할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 건수가 많아질수록 쿼리의 응답 속도가 느리다.                    |

### 9.2.3.1 소트 버퍼
- `소트 버퍼`란 정렬을 수행하기 위한 별도의 `메모리 공간`을 의미
- 정렬이 `필요한 경우`에만 할당
- 정렬해야 할 레코드의 크기에 따라 `가변적`으로 증가
- `sort_buffer_size` 변수를 통해 설정 가능
- 문제점
  - 정렬해야 할 레코드 건수가 소트 버퍼가 할당된 메모리 공간보다 크다면 레코드를 여러 조각으로 나눠 처리한다
  - 이 과정에서 임시 저장을 위해 디스크를 사용하여 디스크 I/O를 유발한다
  - 소트 버퍼 사이즈를 키운다고 성능이 무조건 빨라지지는 않는다

### 9.2.3.2 정렬 알고리즘
- 레코드 정렬 시 레코드 전체를 소트 버퍼에 담을지 or 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 `싱글 패스`, `투 패스`로 나뉜다
- `옵티마이저 트레이스 기능`을 통해 어떤 정렬 모드가 선택됐는지 확인할 수 있다

**싱글 패스 정렬 방식**
- SELECT 대상이 되는 `칼럼 전부`를 소트 버퍼에 담아서 정렬을 수행
- 불필요 데이터까지 읽어 오므로 많은 소트 버퍼 공간이 필요
- 정렬 대상 레코드의 크기나 건수가 `작은 경우` 효율적

**투 패스 정렬 방식**
- `정렬 대상 컬럼`과 `pk`만 소트 버퍼에 담아서 정렬을 수행
- 정렬된 순서대로 다시 pk로 테이블을 `SELECT`하는 방식
- 다음과 같은 경우에 싱글 패스 정렬이 사용되지 못하기 때문에 투 패스 정렬을 사용한다
  1. 레코드의 크기가 `max_length_for_sort_data` 시스템 변수 값보다 큰 경우
  2. `BLOB`이나 `TEXT` 타입의 컬럼이 `SELECT` 대상에 포함될 떄
- 정렬 대상 레코드의 크기나 건수가 `상당히 많은 경우` 효율적

### 9.2.3.3 정렬 처리 방법
| 정렬 처리 방법                           | 실행 계획의 Extra 내용                       | 속도   |
|------------------------------------------|--------------------------------------------|--------|
| 인덱스를 이용한 정렬                    | 별도 표기 없음                             | 빠름   |
| 조인에서 드라이빙 테이블만 정렬         | "Using filesort"                           | 보통   |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort"          | 느림   |

**인덱스를 이용한 정렬**
- `ORDER BY` 절에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, `ORDER BY` 순서대로 생성된 인덱스가 있어야 한다.
- 또한, `WHERE` 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, `ORDER BY`는 같은 인덱스를 사용할 수 있어야 한다
- `B-Tree` 계열의 인덱스가 아닌 `해시`, `전문 검색 인덱스`에서는 정렬을 사용할 수 없다. 
  - 예외적으로 `R-Tree`는 `B-Tree` 계열이긴 하나, 정렬이 불가능하다
- 인덱스는 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다. 즉, 추가 작업을 수행하지 않는다
- 조인을 하더라도 네스티드 루프 방식으로 실행되기 때문에 조인으로 인한 순서가 흐트러지지 않는다
- ex)
    ```sql
    SELECT *
    FROM users, posts
    WHERE users.id = posts.user_id
        AND users.id BETWEEN 10000 AND 10010
    ORDER BY users.id;
    ```
  - 위 쿼리는 user의 정렬된 pk를 읽고 posts의 테이블을 읽기 때문에 ORDER BY를 생략하더라도 정렬되어 조회된다 

**조인의 드라이빙 테이블만 정렬**
- 조인이 수행되면 레코드 수가 크게 증가한다. 따라서 조인 전 첫 번째 테이블의 레코드를 먼저 정렬 후 조인을 실행하는 것이 정렬의 차선책이다
- 따라서 이 방법으로 처리되려면 조인에서 첫 번째로 읽히는 테이블의 칼럼만으로 `ORDER BY`절을 작성해야 한다
- ex)
    ```sql
    SELECT *
    FROM users, posts
    WHERE users.id = posts.user_id
        AND users.id BETWEEN 10000 AND 10010
    ORDER BY users.name;
    ```
    1. 인덱스를 이용해 `WHERE`절을 만족하는 레코드를 검색
    2. 검색 결과를 name 칼럼으로 정렬 수행(Filesort)
    3. 정렬된 결과를 순서대로 읽으면서 posts 테이블과 조인 수행 

**임시 테이블을 이용한 정렬**
- 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있다
- ex)
    ```sql
    SELECT *
    FROM users, posts
    WHERE users.id = posts.user_id
        AND users.id BETWEEN 10000 AND 10010
    ORDER BY posts.title;
    ```
  - 정렬이 수행되기 전 posts 테이블을 읽어야 하므로 이 쿼리는 조인된 데이터를 가지고 정렬할 수밖에 없다

### 9.2.3.4 정렬 처리 방법의 성능 비교
- 일반적으로 `LIMIT`은 처리하는 양을 줄일 수 있기 때문에 서버가 처리할 작업량을 줄일 수 있다고 생각한다. 
- 하지만 데이터를 처리하는 방식에 따라 `LIMIT`으로 처리량이 줄 수도있고 줄지 않을 수도 있다.

**스트리밍 방식**
- 조건에 일치하는 레코드가 `검색될 떄마다` 바로바로 클라이언트로 전송해주는 방식
- 레코드를 찾는 즉시 전달받기 때문에 `동시에` 데이터의 가공 작업을 시작할 수 있다
- 빠른 응답시간을 보장한다

**버퍼링 방식**
- 조건에 일치하는 `모든 레코드`를 가져온 후, 정렬 및 그루핑 작업을 실시한다
- 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다린다
- 응답 속도가 느림

**결론**
- 인덱스를 사용한 정렬 방식만 스트리밍 방식을 사용하고, 나머지는 버퍼링된 후 정렬된다
- 즉, 인덱스를 사용한 정렬 방식은 `LIMIT`으로 제한된 건수만큼만 읽으면 바로 클라이언트에게 전송해줄 수 있다
- 가능하다면 `인덱스를 사용한 정렬`로 유도하자

## 9.2.4 GROUP BY 처리
- `GROUP BY`는 `ORDER BY`와 같이 스트리밍 처리를 할 수 없게 만든다
- `GROUP BY`에서 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 `HAVING` 절을 튜닝할 필요가 없다
- 인덱스를 이용하는 `GROUP BY`
  - 인덱스 스캔: 인덱스를 차례로 읽는 방식
  - 루스 인덱스 스캔: 인덱스를 건너 뛰며 읽는 방식
- 인덱스를 이용하지 않는 `GROUP BY`
  - 임시 테이블을 사용

### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
- 조건
  - 조인 드라이빙 테이블에 속한 칼럼만을 이용해 그루핑
  - `GROUP BY`의 순서로 인덱스가 있어야 함

### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
- 실행 계획의 Extra 컬럼에 `Using index for group-by` 코멘트가 표시된다
- ex)
  ``` sql
  # 인덱스(emp_no, from_date)가 생성된 상태
  SELECT emp_no
  FROM salaries
  WHERE from_date='1985-03-01'
  GROUP BY emp_no;
  ```
  - WHERE 절의 from_date는 복합 인덱스의 첫 컬럼이 아니므로 인덱스를 사용할 수 없다
  - 하지만 위 쿼리의 실행 계획을 보면 인덱스 레인지 스캔을, GROUP BY 처리도 인덱스를 사용한다
    1. (emp_no, from_date) 인덱스를 스캔하며 emp_no의 첫 번째 유일한 값 “10001” 을 찾는다.
    2. 인덱스에서 emp_no가 “10001”인 것 중 from_date 값이 “1985-03-01”인 레코드를 찾는다.
    3. 다시 emp_no의 유일한 값을 찾은 뒤 2번을 반복하고 더 이상 유일한 값이 없으면 처리를 종료한다. 
       - 즉 인덱스의 첫 번째 컬럼의 유니크한 값들 별로 WHERE 조건에 해당하는 레코드를 검색하는 것이다. 

### 9.2.4.3 임시 테이블을 사용하는 GROUP BY
- 인덱스를 사용하지 못할 때 임시 테이블을 사용
- `GROUP BY` 절의 칼럼들로 구성된 `유니크 인덱스`를 가진 `임시 테이블`을 만들어서 `중복 제거`와 `집합 합수 연산`을 수행한다.

## 9.2.5 DISTINCT 처리
- 특정 칼럼의 유니크한 값만 조회하는 기능
- 집합 함수(MIN(), MAX(), COUNT())와 같이 사용되는 경우와 그렇지 않은 경우로 나뉨

### 9.2.5.1 SELECT DISTINCT ...
- 이 경우 GROUP BY와 동일한 방식으로 처리된다
- ```sql
  select distinct emp_no from salaries;
  
  select emp_no from salaries group by emp_no;
  ```
- `DISTINCT`는 `SELECT` 하는 `모든 대상 컬럼`에 대해 `유니크`하게 조회하는 것이다. 
  - 특정 칼럼만 유니크하게 조회하는 것이 아니다. 
  - 괄호를 쳐도 의미없다
  ```sql
  select distinct(first_name), last_name from employees;
  ```

### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT
- 집합 함수 내에서 사용된 `DISTINCT`는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다
- 집합함수와 함께 사용할 때에는 `항상` `임시 테이블`을 생성한다.
  ```sql
  select count(distinct s.salary)
  from employees e, salaries s
  where e.emp_no = s.emp_no
  and e.emp_no between 10001 and 100100;
  ```
  - 위의 쿼리를 실행했을 때 조인한 결과에서 salary를 저장하기 위한 임시테이블을 만든다.
  - salary 칼럼은 유니크 인덱스가 생성된다

## 9.2.6 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 `내부적인 임시 테이블(Internal temporary table)`을 사용한다.
- 내부적인 임시 테이블은 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다. 
- 또한 다른 세션이나 쿼리에서는 볼 수 없고 쿼리가 완료되면 `자동으로 삭제`된다.

**임시 테이블이 필요한 쿼리**
- 다음과 같은 쿼리는 MySQL 엔진에서 별도의 데이터 가공이 필요하므로 내부 임시 테이블을 생성하는 대표적인 케이스이다.
- 임시 테이블을 사용하는 지 여부는 실행 계획의 `Extra 칼럼`에 `Using temporary` 메시지가 표시되는지 확인하면 알 수 있다.
1. `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
2. `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
3. `DISTINCT`와  `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 distinct가 인덱스로 처리되지 못하는 쿼리
4. `UNINON`이나 `UNION DISTINCT`가 사용된 쿼리(select_type이 union result인 경우)

# 9.3 고급 최적화
