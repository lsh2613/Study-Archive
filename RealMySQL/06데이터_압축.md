# 06 데이터 압축
> 데이터 파일이 크면 저장 공간, 쿼리 처리, 백업, 복구에 매우 비효율적이다. 이를 해결하기 위해 많은 DBMS가 데이터 압축을 제공한다

# 6.1 페이지 압축
- `Transparent Page Compression` 이라고도 부름
- 디스크에 저장하는 시점에 데이터 페이지가 압축되어 저장
- 디스크에서 데이터 페이지를 읽을 때 압축 해제
- `InnoDB`는 `버퍼 풀`에 데이터 페이지가 한 번 적재되면 압축이 해제된 상태로만 데이터 페이지를 관리한다
- 하나의 테이블은 동일한 크기의 페이지(블록)로 통일돼야 함
    - 그래서 페이지 압축 기능은 `펀치 홀` 기능을 사용함

## 페이지 압축 방식 (펀치 홀)
1. 16KB 페이지를 압축 (압축 결과를 7KB로 가정)
2. MySQL 서버는 디스크에 압축된 결과 7KB를 기록
3. 디스크에 데이터를 기록한 후, 7KB 이후의 공간 9KB에 대해 펀치 홀을 생성
4. 파일 시스템은 7KB만 남기고 나머지 디스크의 9KB 공간은 다시 운영체제로 반납

- 위 방식으로 특정 테이블에 대해 16KM 크기의 페이지를 유지하면서, 압축된 만큼의 `공간을 절약`

## 문제점
1. OS뿐만 아니라 `하드웨어` 자체에서 해당 기능을 지원해야 사용 가능
2. 아직 `파일 시스템` 관련 명령어가 펀치 홀을 지원하지 못함

# 6.2 테이블 압축
- 디스크의 데이터 파일 크기를 줄인다
- OS, 하드웨어 제약 없이 사용 가능
- 단점
    1. 버퍼 풀 공간 활용률이 낮음
    2. 쿼리 처리 성능이 낮음
    3. 빈번한 데이터 변경 시 압축률 저하

## 6.2.1 압축 테이블 생성
- 테이블 압축을 사용하려는 테이블이 별도의 테이블 스페이스를 사용해야 함
- `innodb_file_per_table = ON` 상태로 `ROW_FORMAT+COMPRESSED`옵션을 명시하여 테이블을 생성해야 한다
- `KEY_BLOCK_SIZE` 옵션을 사용하여 타깃 크기를 명시
- ``` sql
    mysql> SET GLOBAL innodb_file_per_table=ON;

    mysql> CREATE TABLE compressed_table (
            c1 INT PRIMARY KEY
            )
            ROW_FORMAT=COMPRESSED
            KEY_BLOCK_SIZE=8;
    ```

### 테이블 압축 방식
1. 16KB의 데이터 페이지를 압축
2. 압축된 결과가 8KB 이하이면 그대로 디스크에 저장(압축 완료)
3. 압축된 결과가 8KB를 초과하면 원본 페이지를 스플릿(split)해서 2개의 페이지에 8KB씩 저장
4. 나뉜 페이지 각각에 대해 1번 단계를 반복 실행

## 6.2.2 KEY_BLOCK_SIZE 결정
- 압축된 결과가 어느 정도가 될지를 예측해서 사이즈를 결정해야 한다
- 압축을 적용하기 전 `KEY_BLOCK_SIZE`를 4KB or 8KB로 테이블을 생성해서 샘플 데이터를 저장해보고 판단하는 것이 좋다
- 압축 실패율이 `3~5%` 미만으로 유지할 수 있게 설정
    - 압축 실패는 압축 결과가 설정한 KEY_BLOCK_SIZE 보다 커서 재 압축을 실행했다는 의미
- 압축 실패율이 높다 -> InnoDB 버퍼 풀에서 디스크로 기록되기 전에 압축하는 과정이 꽤 오래 걸린다

## 6.2.3 압축된 페이지의 버퍼 풀 적재 및 사용
- InnoDB는 압축된 테이블의 데이터 페이지를 버퍼 풀에 적재하면 `압축된 상태`와 `압축 해제된 상태` 2개 버전을 관리한다
- LRU 리스트
    - 압축이 적용되지 않은 테이블의 데이터 페이지
    - 압축이 적용된 테이블의 압축된 데이터 페이지
- Unzip_LRU 리스트
    - 압축된 페이지들의 `압축 해제 버전`을 관리

### 단점
1. 압축된 테이블에 대해서 버퍼 풀의 공간을 `이중`으로 사용함 ⇒ 메모리 낭비
2. 압축된 페이지에서 데이터를 읽거나 변경하기 위해서는 압축을 해제해야 함
3. 압축 및 압축 해제 작업은 CPU를 많이 소모함 ⇒ Unzip_LRU 리스트를 별도로 관리함

### 해결 방안
- Unzip_LRU 리스트를 별도로 관리하다가 요청 패턴에 따라 적절히(Adaptive) 다음과 같은 처리 수행
    1. InnoDB 버퍼 풀의 공간이 필요한 경우, LRU 리스트에서 원본 데이터 페이지(압축된 형태)는 유지 & Unzip_LRU 리스트에서 압축 해제된 버전은 제거
    2. 압축된 데이터 페이지가 자주 사용 → Unzip_LRU 리스트에 압축 해제된 페이지를 계속 유지하면서 압축 및 해제 작업을 최소화
    3. 압축된 데이터 페이지가 사용되지 않아 LRU 리스트에서 제거 → Unzip_LRU 리스트에서도 함께 제거

### 어댑티브(적응적인) 알고리즘
-  압축 해제된 버전의 데이터 페이지를 적절한 수준으로 유지하기 위한 방법
    -  CPU 사용량이 높은 서버 → Unzip_LRU의 비율 높이기 ⇒ 압축과 압축 해제 피하기
    -  Disk IO 사용량이 높은 서버 → Unzip_LRU의 비율 줄이기 ⇒ InnoDB 버퍼 풀의 공간을 더 확보하기